<!DOCTYPE html>
<html>
<head>

<title>BG3 Item Checklist</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="./favicon.png"/>
<link rel="stylesheet" href="./style.css"></style>
<script src="https://unpkg.com/vue@3.5.13/dist/vue.global.js"></script>
<script src="https://unpkg.com/vuex@4.0.0/dist/vuex.global.js"></script>
<script src="./data.js"></script>
<script src="./loadSprites.js"></script>
</head>

<body>

<div id="app"></div>

<script>

const { createStore } = Vuex;

function get_difficulty_mod(difficulty) {
	switch (difficulty) {
		case "explorer": return 0.5;
		case "balanced": return 0;
		case "tactician": return -0.5;
		case "honour": return -0.5;
	}
}

<!-- See https://bg3.wiki/wiki/Trading_and_item_pricing and https://bg3.wiki/wiki/Widget:PriceCalculator -->
function get_final_price(value, persuasion_mod = 4, attitude = 0, difficulty = "balanced") {
	let difficulty_mod = get_difficulty_mod(difficulty);
	let price_mod = Math.max(1.0, 2.5 - 0.1*persuasion_mod - 0.005*attitude - difficulty_mod);
	value = value.split(" / ");
	if (value.length == 1 || difficulty != "honour")
		value = value[0];
	else
		value = value[1];
	value = parseInt(value.replace(" gp", ""));
	let price_buy = Math.round(value * price_mod);
	return price_buy + " gp";
}

const Entry = {
	props: ["title", "id", "categories", "rarity", "suggested", "choice", "crafting", "exploit", "img", "link", "desc"],
	inject: ["filters"],
	template: `
<div :class="['entry', categories, rarity, {'top-tier': suggested, 'completed': $store.state.checkboxState[id]}]" :id="id" v-show="visible">
<span class="checkbox"><input type="checkbox" :checked="$store.state.checkboxState[id]" @change="$emit('toggleCheckbox')"></span>
<span class="img" @click="$emit('toggleCheckbox')"><img :src="img" width=50 height=50></span>
<span class="title"><a :href="link">{{ title }}</a></span>
<span class="desc" v-html="desc"></span>
</div>
`,
	mounted() {
		if (this.progress)
			this.$emit("updateProgress", 1, this.categories);
		if (this.total)
			this.$emit("updateTotal", 1, this.categories);
	},
	computed: {
		visible() {
			if (this.$store.state.searchString.length && !this.desc.toLowerCase().includes(this.$store.state.searchString)) {
				return false;
			}
			if (this.$store.state.checkboxState[this.id] && !this.$store.state.showCompleteState) {
				return false;
			}
			for (const filter of this.filters) {
				for (const cat of this.categories) {
					if (filter.categories.includes(cat) && this.$store.state.filterState[filter.id]) {
						return true;
					}
				}
				for (const subfilter of filter.subfilters) {
					for (const cat of this.categories) {
						if (subfilter.categories.includes(cat) && this.$store.state.filterState[subfilter.id]) {
							return true;
						}
					}
				}
			}
			return false;
		},
		progress() {
			return (this.visible && this.$store.state.checkboxState[this.id]) ? 1 : 0;
		},
		total() {
			return (this.visible) ? 1 : 0;
		}
	},
	watch: {
		progress(newVal, oldVal) {
			this.$emit("updateProgress", newVal-oldVal, this.categories);
		},
		total(newVal, oldVal) {
			this.$emit("updateTotal", newVal-oldVal, this.categories);
		}
	}
}

const EntryContainer = {
	props: ["title", "id", "tip", "entries"],
	template: `
<div :id="id" :class="[(entries[0].entries !== undefined) ? 'meta-container':'container', {started: progress, completed: progress == total, expanded: this.$store.state.expansionState[id]}]" v-show="total || preMount">

<div class="header">
	<span class="eye noselect" @click="expandContent(!this.$store.state.expansionState[id]); $emit('toggleExpansion');">üëÅÔ∏è</span>
	<span class="title">{{ title }}</span>
	<span class="progress">{{ progress }}/{{total }}</span>
	<span class="text-button noselect" @click="$emit('clearCheckboxes')">Clear</span>
</div>

<div ref="content" class="content">

	<div v-if="tip" class="tip" v-html="tip"></div>

	<EntryContainer
		v-if="entries[0].entries !== undefined"
		v-for="entry in entries"
		:title="entry.title"
		:id="entry.id"
		:tip="entry.tip"
		:entries="entry.entries"
		@toggleExpansion="$store.dispatch('toggleExpansionAndSave', entry)"
		@clearCheckboxes="$store.dispatch('clearAllCheckboxesAndSave', entry)"
		@updateProgress="updateProgress"
		@updateTotal="updateTotal"
	>
	</EntryContainer>

	<Entry
		v-else
		v-for="entry in entries"
		:title="entry.title"
		:id="entry.id"
		:categories="entry.categories"
		:rarity="entry.rarity"
		:suggested="entry.suggested"
		:choice="entry.choice"
		:crafting="entry.crafting"
		:exploit="entry.exploit"
		:img="entry.img"
		:link="entry.link"
		:desc="entry.desc"
		@toggleCheckbox="$store.dispatch('toggleCheckboxAndSave', entry)"
		@updateProgress="updateProgress"
		@updateTotal="updateTotal"
	>
	</Entry>
</div>
</div>
`,
	mounted() {
		const contentDiv = this.$refs.content;
		//contentDiv.style.maxHeight = contentDiv.scrollHeight + "px";
		this.expandContent(this.$store.state.expansionState[this.id]);
		this.preMount = false;
	},
	data() {
		return {
			progress: 0,
			total: 0,
			preMount: true // needed to get correct scrollHeight during initial render
		}
	},
	methods: {
		updateProgress(amount, categories) {
			this.progress += amount;
			this.$store.state.countProgress[this.id] = this.progress;
			this.$emit("updateProgress", amount, categories);
		},
		updateTotal(amount, categories) {
			this.total += amount;
			this.$store.state.countTotal[this.id] = this.total;
			this.$emit("updateTotal", amount, categories);
			// ensure entry has actually become visible before updating height
			this.$nextTick(() => {
				this.expandContent(this.$store.state.expansionState[this.id]);
			});
		},
		expandContent(expand) {
			const contentDiv = this.$refs.content;
			if (expand) {
				contentDiv.style.maxHeight = null; //contentDiv.scrollHeight + "px"; // TODO transitioning open is causing a lot of height errors
			} else {
				contentDiv.style.maxHeight = "0px";
			}
		}
	}
}

const filterOption = {
	props: ["filter"],
	template: `
<div class="filter" @mouseover="mouse=true; expandSubcategories(true)" @mouseout="expandSubcategories(false)" @blur="expandSubcategories(false)">
<div
	class="toggle-button"
	:class="{
		enabled: (filter.subfilters.length == 0 && $store.state.filterState[filter.id]) || filter.subfilters.some(sf => $store.state.filterState[sf.id]),
		'fully-enabled': (filter.subfilters.length == 0 && $store.state.filterState[filter.id]) || (filter.subfilters.length && filter.subfilters.every(sf => $store.state.filterState[sf.id]))
	}"
	@click="mouse ? $store.dispatch('toggleFilterAndSave', filter) : expandSubcategories(true)"
>
	<span class="eye" @click="mouse ? null : $store.dispatch('toggleFilterAndSave', filter)">üëÅÔ∏è</span>
	<span>{{ filter.id }}</span>
</div>
<div ref="subfilters" class="subfilters">
	<div
		v-for="subfilter in filter.subfilters"
		class="toggle-button"
		:class="{enabled: $store.state.filterState[subfilter.id], 'fully-enabled': $store.state.filterState[subfilter.id]}"
		@click="$store.dispatch('toggleFilterAndSave', subfilter)"
	>
		<span class="eye">üëÅÔ∏è</span>
		<span>{{ subfilter.id }}</span>
	</div>

</div>
</div>
`,
	data() {
		return {
			mouse: false
		}
	},
	methods: {
		expandSubcategories(expand) {
			const subcategoriesDiv = this.$refs.subfilters;
			if (expand) {
				subcategoriesDiv.style.maxHeight = subcategoriesDiv.scrollHeight + "px";
			} else {
				subcategoriesDiv.style.maxHeight = "0px";
			}
		}
	}
}

const app = Vue.createApp({
	template: `
<h1>BG3 Item Checklist</h1>
<p><a href="https://github.com/joe1817/BG3-Item-Checklist">GitHub</a></p>
<h2>Table of Contents</h2>

<div id="back-to-top" class="text-button noselect" @click="scrollToTop">Back to Top</div>

<div id="TOC">
<ol v-for="act in entryData.entries">
	<li>
		<ul>
			<li v-for="section in act.entries" :class="{started: $store.state.countProgress[section.id], completed: $store.state.countProgress[section.id] == $store.state.countTotal[section.id], active: $store.state.countTotal[section.id]}">
				<a v-if="$store.state.countTotal[section.id]" :href="'#'+section.id">{{ section.title }}</a>
				<span v-else>{{ section.title }}</span>
				<span class="progress">{{ $store.state.countProgress[section.id] }}/{{ $store.state.countTotal[section.id] }}</span>
			</li>
		</ul>
	</li>
</ol>
</div>

<div id="options">
<fieldset id="filters" class="noselect">
	<legend>Filters</legend>
	<filterOption v-for="filter in filters" :filter="filter"></filterOption>
</fieldset>

<fieldset id="more-options" class="noselect">
	<legend>More Options</legend>
	<div class="toggle-button"
		:class="{enabled: $store.state.showCompleteState, 'fully-enabled': $store.state.showCompleteState}"
		@click="$store.dispatch('toggleHideCompleteAndSave')"
	>
		<span class="eye">üëÅÔ∏è</span>
		<span>Show Completed</span>
	</div>
</fieldset>

<fieldset id="search">
	<legend>Search</legend>
	<div class="search-input-wrapper">
		<input
			type="text"
			ref="searchBar"
			class="search-input"
			@keyup ="$store.commit('updateSearchString', $event.target.value.toLowerCase())"
			placeholder="Search..."
		>
		<button class="clear-button" @click="$refs.searchBar.value=''; $store.commit('updateSearchString', '')">√ó</button>
	</div>
</fieldset>
</div>

<div id="table">
<EntryContainer
	:title="'All Items'"
	:id="'all-items'"
	:tip="''"
	:entries="entryData.entries"
	@toggleExpansion="$store.dispatch('toggleExpansionAndSave', entryData)"
	@clearCheckboxes="$store.dispatch('clearAllCheckboxesAndSave', entryData)"
>
</EntryContainer>
</div>
`,
	data() {
		return {
			entryData : entryData,
			filters   : filters
		};
	},
	provide() {
		return {
			filters : this.filters
		}
	},
	mounted() {
		const backToTop = document.getElementById("back-to-top");
		window.addEventListener("scroll", () => {
			if (window.scrollY > 1200) {
				backToTop.style.visibility = "visible";
				backToTop.style.opacity = 1;
			} else {
				backToTop.style.opacity = 0;
				setTimeout(() => {
					if (backToTop.style.opacity === 0) {
						backToTop.style.visibility = "hidden";
					}
				}, 200);
			}
		});

		// calculate buy prices from entry value
		document.querySelectorAll(".value").forEach(value => {
			value.innerText = get_final_price(value.innerText);
		});

		loadSprites();
	},
	methods: {
		scrollToTop() {
			window.scrollTo({top: 0, behavior: 'smooth'});
		}
	}
});

app.component("filterOption", filterOption);
app.component("Entry", Entry);
app.component("EntryContainer", EntryContainer);








const setParentRefs = (container, childrenProperty) => {
	if (container[childrenProperty] !== undefined) {
		for (const entry of container[childrenProperty]) {
			entry.parent = container;
			setParentRefs(entry, childrenProperty);
		}
	}
}
setParentRefs(entryData, "entries");
for (const filter of filters)
	setParentRefs(filter, "subfilters");

const checked   = (localStorage.getItem("checked")   || "").split(",");
const collapsed = (localStorage.getItem("collapsed") || "").split(",");
const disabled  = (localStorage.getItem("disabled")  || "").split(",");
const showComplete  = (localStorage.getItem("showComplete") == "false") ? false : true;

const filterState = {};
const expansionState = {};
const checkboxState = {};

const countProgress = {}
const countTotal = {}

for (const filter of filters) {
	filterState[filter.id] = !disabled.includes(filter.id);
	for (const subfilter of filter.subfilters) {
		filterState[subfilter.id] = !disabled.includes(subfilter.id);
	}
}

const fillState = (entry) => {
	if (entry.entries === undefined) {
		checkboxState[entry.id] = checked.includes(entry.id);
	} else {
		countProgress[entry.id] = 0
		countTotal[entry.id] = 0
		expansionState[entry.id] = !collapsed.includes(entry.id);
		for (const entry2 of entry.entries) {
			fillState(entry2);
		}
	}
}
fillState(entryData);

const store = createStore({
	state() {
		return {
			filterState: filterState,
			expansionState: expansionState,
			checkboxState: checkboxState,
			showCompleteState: showComplete,

			searchString: "",
			countProgress: countProgress,
			countTotal: countTotal
		}
	},
	mutations: {
		toggleFilter(state, filter) {
			state.filterState[filter.id] = !state.filterState[filter.id];

			if (filter.parent === undefined) {
				for (const subfilter of filter.subfilters) {
					state.filterState[subfilter.id] = state.filterState[filter.id];
				}
			} else {
				const count = filter.parent.subfilters.filter(sf => state.filterState[sf.id]).length;
				if (count == filter.parent.subfilters.length) {
					state.filterState[filter.parent.id] = true;
				} else {
					state.filterState[filter.parent.id] = false;
				}
			}
		},
		toggleExpansion(state, container) {
			state.expansionState[container.id] = !state.expansionState[container.id];
		},
		toggleCheckbox(state, entry) {
			state.checkboxState[entry.id] = !state.checkboxState[entry.id];
		},
		toggleHideComplete(state) {
			state.showCompleteState = !state.showCompleteState;
		},
		clearAllCheckboxes(state, container) {
			const clear = (container) => {
				for (const entry of container.entries) {
					if (entry.entries === undefined) {
						state.checkboxState[entry.id] = false;
					} else {
						clear(entry);
					}
				}
			}
			clear(container);
		},
		updateSearchString(state, s) {
			state.searchString = s;
		}
	},
	actions: {
		toggleFilterAndSave({ commit, state }, payload) {
			commit("toggleFilter", payload);

			let obj = state.filterState;
			let data = Object.keys(obj).filter(key => obj[key] === false).join(",");
			localStorage.setItem("disabled", data);
		},
		toggleExpansionAndSave({ commit, state }, payload) {
			commit("toggleExpansion", payload);

			let obj = state.expansionState;
			let data = Object.keys(obj).filter(key => obj[key] === false).join(",");
			localStorage.setItem("collapsed", data);
		},
		toggleCheckboxAndSave({ commit, state }, payload) {
			commit("toggleCheckbox", payload);

			let obj = state.checkboxState;
			let data = Object.keys(obj).filter(key => obj[key] === true).join(",");
			localStorage.setItem("checked", data);
		},
		toggleHideCompleteAndSave({ commit, state }) {
			commit("toggleHideComplete");

			localStorage.setItem("showComplete", state.showCompleteState);
		},
		clearAllCheckboxesAndSave({ commit, state }, payload) {
			commit("clearAllCheckboxes", payload);

			let obj = state.checkboxState;
			let data = Object.keys(obj).filter(key => obj[key] === true).join(",");
			localStorage.setItem("checked", data);
		}
	}
})

app.use(store)

document.addEventListener("DOMContentLoaded", () => {
	app.mount("#app");
});

</script>

</body>
</html>
