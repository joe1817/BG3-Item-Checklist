<!DOCTYPE html>
<html>
<head>

<title>BG3 Item Checklist</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="./favicon.png"/>
<link rel="stylesheet" href="./style.css"></style>
<script src="https://unpkg.com/vue@3.5.13/dist/vue.global.js"></script>
<script src="https://unpkg.com/vuex@4.0.0/dist/vuex.global.js"></script>
<script src="./data.js"></script>
<script src="./loadSprites.js"></script>
<script src="./highlight.js"></script>
</head>

<body>

<div id="app"></div>

<script>

const { createStore } = Vuex;

function get_difficulty_mod(difficulty) {
	switch (difficulty) {
		case "explorer": return 0.5;
		case "balanced": return 0;
		case "tactician": return -0.5;
		case "honour": return -0.5;
	}
}

<!-- See https://bg3.wiki/wiki/Trading_and_item_pricing and https://bg3.wiki/wiki/Widget:PriceCalculator -->
function get_final_price(value, persuasion_mod = 4, attitude = 0, difficulty = "balanced") {
	let difficulty_mod = get_difficulty_mod(difficulty);
	let price_mod = Math.max(1.0, 2.5 - 0.1*persuasion_mod - 0.005*attitude - difficulty_mod);
	value = value.split(" / ");
	if (value.length == 1 || difficulty != "honour")
		value = value[0];
	else
		value = value[1];
	value = parseInt(value.replace(" gp", ""));
	let price_buy = Math.round(value * price_mod);
	return price_buy + " gp";
}

const Entry = {
	props: ["entry"],
	inject: ["filters"],
	template: `
<div
	ref="content"
	:class="['entry', entry.categories, entry.rarity, {'top-tier': entry.suggested, 'completed': $store.state.checkboxState[entry.id]}]"
	:id="entry.id"
	v-show="visible || preMount"
	@click="handleClick($event)"
>
	<span class="checkbox"><input type="checkbox" :checked="$store.state.checkboxState[entry.id]"></span>
	<span v-show="$store.state.showImagesState" class="img"><img :src="entry.img" width=50 height=50></span>
	<span class="title"><a :href="entry.link">{{ entry.title }}</a></span>
	<span class="desc" v-html="highlight(entry.desc)"></span>
</div>
`,
	mounted() {
		if (this.progress)
			this.$emit("updateProgress", 1, this.entry.categories);
		if (this.total)
			this.$emit("updateTotal", 1, this.entry.categories);
		this.height = this.$refs.content.scrollHeight;
		this.preMount = false;
	},
	data() {
		return {
			preMount: true,
			height: null
		}
	},
	methods: {
		handleClick(event) {
			if (event.target.tagName !== "A") {
				this.$store.dispatch('toggleCheckboxAndSave', this.entry)
			}
		},
		highlight(text){
			if (!this.$store.state.searchString) {
				return text;
			} else if (text.toLowerCase().includes(this.$store.state.searchString)) {
				return highlightSubstring(text, this.$store.state.searchString)
			} else {
				return text;
			}
		}
	},
	computed: {
		visible() {
			if (this.$store.state.searchString.length && !this.entry.desc.toLowerCase().includes(this.$store.state.searchString)) {
				return false;
			}
			if (this.$store.state.checkboxState[this.entry.id] && !this.$store.state.showCompleteState) {
				return false;
			}
			for (const filter of this.filters) {
				for (const cat of this.entry.categories) {
					if (filter.categories.includes(cat) && this.$store.state.filterState[filter.id]) {
						return true;
					}
				}
				for (const subfilter of filter.subfilters) {
					for (const cat of this.entry.categories) {
						if (subfilter.categories.includes(cat) && this.$store.state.filterState[subfilter.id]) {
							return true;
						}
					}
				}
			}
			return false;
		},
		progress() {
			return (this.visible && this.$store.state.checkboxState[this.entry.id]) ? 1 : 0;
		},
		total() {
			return (this.visible) ? 1 : 0;
		}
	},
	watch: {
		progress(newVal, oldVal) {
			this.$emit("updateProgress", newVal-oldVal, this.entry.categories);
		},
		total(newVal, oldVal) {
			this.$emit("updateTotal", newVal-oldVal, this.entry.categories);
		},
		visible(newVal, oldVal) {
			if (newVal) {
				this.$emit("updateHeight", this.height);
			} else {
				this.$emit("updateHeight", -this.height);
			}
		}
	}
}

const EntryContainer = {
	props: ["entry", "collapsible"],
	template: `
<div
	:id="entry.id"
	:class="[(entry.entries[0].entries !== undefined) ? 'meta-container':'container', {started: progress, completed: progress == total, expanded: this.$store.state.expansionState[entry.id]}]"
	v-show="total || preMount"
>

	<div class="header">
		<span v-if="collapsible" class="eye noselect" @click="collapseHandler">üëÅÔ∏è</span>
		<span class="title">{{ entry.title }}</span>
		<span v-if="trackable"  class="progress">{{ progress }}/{{ total }}</span>
		<span v-if="clearable" class="text-button clear-button noselect" @click="clearHandler">Clear</span>
	</div>

	<div ref="content" class="content">

		<div v-if="entry.tip" class="tip" v-html="entry.tip"></div>

		<EntryContainer
			v-if="entry.entries[0].entries !== undefined"
			v-for="subentry in entry.entries"
			:entry="subentry"
			@toggleExpansion="$store.dispatch('toggleExpansionAndSave', subentry)"
			@clearCheckboxes="$store.dispatch('clearAllCheckboxesAndSave', subentry)"
			@updateProgress="updateProgress"
			@updateTotal="updateTotal"
			@updateHeight="updateHeight"
		>
		</EntryContainer>

		<Entry
			v-else
			v-for="subentry in entry.entries"
			:entry="subentry"
			@toggleCheckbox="$store.dispatch('toggleCheckboxAndSave', subentry)"
			@updateProgress="updateProgress"
			@updateTotal="updateTotal"
			@updateHeight="updateHeight"
		>
		</Entry>
	</div>
</div>
`,
	props: {
		entry: {},
		collapsible: {
			type: Boolean,
			default: true
		},
		trackable: {
			type: Boolean,
			default: true
		},
		clearable: {
			type: Boolean,
			default: true
		}
	},
	mounted() {
		this.updateHeight(this.$refs.content.scrollHeight);
		this.preMount = false;
	},
	data() {
		return {
			progress: 0,
			total: 0,
			height: 0,
			preMount: true // needed to get correct scrollHeight during initial render
		}
	},
	methods: {
		collapseHandler() {
			this.expandContent(!this.$store.state.expansionState[this.entry.id]);
			this. $store.dispatch("toggleExpansionAndSave", this.entry);
		},
		clearHandler() {
			if (window.confirm("Clear all checkboxes for section \"" + this.entry.title + "\"?")) {
				this.$store.dispatch("clearAllCheckboxesAndSave", this.entry);
			}
		},
		updateProgress(amount, categories) {
			this.progress += amount;
			this.$store.state.countProgress[this.entry.id] = this.progress;
			this.$emit("updateProgress", amount, categories);
		},
		updateTotal(amount, categories) {
			this.total += amount;
			this.$store.state.countTotal[this.entry.id] = this.total;
			this.$emit("updateTotal", amount, categories);
		},
		updateHeight(amount) {
			this.height += amount;
			this.expandContent(this.$store.state.expansionState[this.entry.id]);
			this.$emit("updateHeight", amount);
		},
		expandContent(expand) {
			const contentDiv = this.$refs.content;
			if (expand) {
				contentDiv.style.maxHeight = this.height + "px";
			} else {
				contentDiv.style.maxHeight = "0px";
			}
		}
	}
}

const filterOption = {
	props: ["filter"],
	template: `
<div ref="filter" class="filter main-option" @mouseover="mouseoverHandlder($event)" @mouseout="mouseoutHandlder($event)" @blur="blurHandlder($event)">
	<div
		class="toggle-button"
		:class="{
			enabled: (filter.subfilters.length == 0 && $store.state.filterState[filter.id]) || filter.subfilters.some(sf => $store.state.filterState[sf.id]),
			'fully-enabled': (filter.subfilters.length == 0 && $store.state.filterState[filter.id]) || (filter.subfilters.length && filter.subfilters.every(sf => $store.state.filterState[sf.id]))
		}"
		@click="mouse ? $store.dispatch('toggleFilterAndSave', filter) : expandSubcategories(true)"
	>
		<span class="eye" @click="mouse ? null : $store.dispatch('toggleFilterAndSave', filter)">üëÅÔ∏è</span>
		<span>{{ filter.id }} <span v-if="filter.subfilters.length" style="font-size:8px;line-height:1;">‚ñº</span></span>
	</div>
	<div ref="subfilters" class="subfilters">
		<div
			v-for="subfilter in filter.subfilters"
			class="toggle-button"
			:class="{enabled: $store.state.filterState[subfilter.id], 'fully-enabled': $store.state.filterState[subfilter.id]}"
			@click="$store.dispatch('toggleFilterAndSave', subfilter)"
		>
			<span class="eye">üëÅÔ∏è</span>
			<span>{{ subfilter.id }}</span>
		</div>

	</div>
</div>
`,
	data() {
		return {
			mouse: false
		}
	},
	methods: {
		mouseoverHandlder(event) {
			this.mouse = true;
			this.expandSubcategories(true);
		},
		mouseoutHandlder(event) {
			this.expandSubcategories(false);
		},
		blurHandlder(event) {
			this.expandSubcategories(false);
		},
		expandSubcategories(expand) {
			const subcategoriesDiv = this.$refs.subfilters;
			if (expand) {
				subcategoriesDiv.style.maxHeight = subcategoriesDiv.scrollHeight + "px";
			} else {
				subcategoriesDiv.style.maxHeight = "0px";
			}
		}
	}
}

const app = Vue.createApp({
	template: `
<div id="back-to-top" class="text-button noselect" @click="scrollToTop">Back to Top</div>

<h1>BG3 Item Checklist</h1>
<p><a href="https://github.com/joe1817/BG3-Item-Checklist">GitHub</a></p>

<div id="TOC">
	<h2>Table of Contents</h2>
	<div class="acts">
		<div v-for="act in entryData.entries" class="act" ref="act">
			<h3 class="title">{{ act.title }}</h3>
			<div v-for="section in act.entries" :class="['section', {started: $store.state.countProgress[section.id], completed: $store.state.countProgress[section.id] == $store.state.countTotal[section.id], active: $store.state.countTotal[section.id]}]">
				<a v-if="$store.state.countTotal[section.id]" :href="'#'+section.id">{{ section.title }}</a>
				<span v-else>{{ section.title }}</span>
				<span><span class="progress">{{ $store.state.countProgress[section.id] }}/{{ $store.state.countTotal[section.id] }}</span></span>
			</div>
		</div>
	</div>
</div>

<div id="options">
<fieldset id="filters" class="noselect">
	<legend>Filters</legend>
	<div class="content">
		<filterOption v-for="filter in filters" :filter="filter"></filterOption>
	</div>
</fieldset>

<fieldset id="more-options" class="noselect">
	<legend>More Options</legend>
	<div class="content">
		<div class="toggle-button main-option"
			:class="{enabled: $store.state.showCompleteState, 'fully-enabled': $store.state.showCompleteState}"
			@click="$store.dispatch('toggleShowCompleteAndSave')"
		>
			<span class="eye">üëÅÔ∏è</span>
			<span>Show Completed</span>
		</div>
		<div class="toggle-button main-option"
			:class="{enabled: $store.state.showImagesState, 'fully-enabled': $store.state.showImagesState}"
			@click="$store.dispatch('toggleShowImagesAndSave')"
		>
			<span class="eye">üëÅÔ∏è</span>
			<span>Show Images</span>
		</div>
	</div>
</fieldset>

<fieldset id="search">
	<legend>Search</legend>
	<div class="content">
		<div class="search-input-wrapper">
			<input
				type="text"
				ref="searchBar"
				class="search-input main-option"
				@keyup ="$store.commit('updateSearchString', $event.target.value.toLowerCase())"
				placeholder="Search..."
			>
			<div class="clear-button" @click="$refs.searchBar.value=''; $store.commit('updateSearchString', '')">√ó</div>
		</div>
	</div>
</fieldset>
</div>

<div id="table">
<EntryContainer
	:entry="entryData"
	:collapsible=false
	@clearCheckboxes="$store.dispatch('clearAllCheckboxesAndSave', entryData)"
>
</EntryContainer>
</div>
`,
	data() {
		return {
			entryData : entryData,
			filters   : filters
		};
	},
	provide() {
		return {
			filters : this.filters
		}
	},
	mounted() {
		const backToTop = document.getElementById("back-to-top");
		window.addEventListener("scroll", () => {
			if (window.scrollY > 1200) {
				backToTop.style.visibility = "visible";
				backToTop.style.opacity = 1;
			} else {
				backToTop.style.opacity = 0;
				setTimeout(() => {
					if (backToTop.style.opacity === 0) {
						backToTop.style.visibility = "hidden";
					}
				}, 200);
			}
		});

		// set each act in TOC to the same width
		let max = 0;
		this.$refs.act.forEach(act => {
			//act.clientWidth and act.offsetWidth are too small
			// window.getComputedStyle(act).width is too big
			// act.getBoundingClientRect().width is best, but it is a float
			const width = act.offsetWidth + 1; // add 1 to "round up"
			if (width > max) {
				max = width;
			}
		});
		this.$refs.act.forEach(act => {
			act.style.width = max+"px";
		});

		// calculate buy prices from entry value
		document.querySelectorAll(".value").forEach(value => {
			value.innerText = get_final_price(value.innerText);
		});

		loadSprites();
	},
	methods: {
		scrollToTop() {
			window.scrollTo({top: 0, behavior: 'smooth'});
		}
	}
});

app.component("filterOption", filterOption);
app.component("Entry", Entry);
app.component("EntryContainer", EntryContainer);








const setParentRefs = (container, childrenProperty) => {
	if (container[childrenProperty] !== undefined) {
		for (const entry of container[childrenProperty]) {
			entry.parent = container;
			setParentRefs(entry, childrenProperty);
		}
	}
}
setParentRefs(entryData, "entries");
for (const filter of filters)
	setParentRefs(filter, "subfilters");

const checked   = (localStorage.getItem("checked")   || "").split(",");
const collapsed = (localStorage.getItem("collapsed") || "").split(",");
const disabled  = (localStorage.getItem("disabled")  || "").split(",");
const showComplete  = (localStorage.getItem("showComplete") == "false") ? false : true;
const showImages  = (localStorage.getItem("showImages") == "false") ? false : (window.innerWidth > 768);

const filterState = {};
const expansionState = {};
const checkboxState = {};

const countProgress = {}
const countTotal = {}

for (const filter of filters) {
	filterState[filter.id] = !disabled.includes(filter.id);
	for (const subfilter of filter.subfilters) {
		filterState[subfilter.id] = !disabled.includes(subfilter.id);
	}
}

const fillState = (entry) => {
	if (entry.entries === undefined) {
		checkboxState[entry.id] = checked.includes(entry.id);
	} else {
		countProgress[entry.id] = 0
		countTotal[entry.id] = 0
		expansionState[entry.id] = !collapsed.includes(entry.id);
		for (const subentry of entry.entries) {
			fillState(subentry);
		}
	}
}
fillState(entryData);

const store = createStore({
	state() {
		return {
			filterState: filterState,
			expansionState: expansionState,
			checkboxState: checkboxState,
			showCompleteState: showComplete,
			showImagesState: showImages,

			searchString: "",
			countProgress: countProgress,
			countTotal: countTotal
		}
	},
	mutations: {
		toggleFilter(state, filter) {
			state.filterState[filter.id] = !state.filterState[filter.id];

			if (filter.parent === undefined) {
				for (const subfilter of filter.subfilters) {
					state.filterState[subfilter.id] = state.filterState[filter.id];
				}
			} else {
				const count = filter.parent.subfilters.filter(sf => state.filterState[sf.id]).length;
				if (count == filter.parent.subfilters.length) {
					state.filterState[filter.parent.id] = true;
				} else {
					state.filterState[filter.parent.id] = false;
				}
			}
		},
		toggleExpansion(state, container) {
			state.expansionState[container.id] = !state.expansionState[container.id];
		},
		toggleCheckbox(state, entry) {
			state.checkboxState[entry.id] = !state.checkboxState[entry.id];
		},
		toggleShowComplete(state) {
			state.showCompleteState = !state.showCompleteState;
		},
		toggleShowImages(state) {
			state.showImagesState = !state.showImagesState;
		},
		clearAllCheckboxes(state, container) {
			const clear = (container) => {
				for (const entry of container.entries) {
					if (entry.entries === undefined) {
						state.checkboxState[entry.id] = false;
					} else {
						clear(entry);
					}
				}
			}
			clear(container);
		},
		updateSearchString(state, s) {
			state.searchString = s;
		}
	},
	actions: {
		toggleFilterAndSave({ commit, state }, payload) {
			commit("toggleFilter", payload);

			let obj = state.filterState;
			let data = Object.keys(obj).filter(key => obj[key] === false).join(",");
			localStorage.setItem("disabled", data);
		},
		toggleExpansionAndSave({ commit, state }, payload) {
			commit("toggleExpansion", payload);

			let obj = state.expansionState;
			let data = Object.keys(obj).filter(key => obj[key] === false).join(",");
			localStorage.setItem("collapsed", data);
		},
		toggleCheckboxAndSave({ commit, state }, payload) {
			commit("toggleCheckbox", payload);

			let obj = state.checkboxState;
			let data = Object.keys(obj).filter(key => obj[key] === true).join(",");
			localStorage.setItem("checked", data);
		},
		toggleShowCompleteAndSave({ commit, state }) {
			commit("toggleShowComplete");

			localStorage.setItem("showComplete", state.showCompleteState);
		},
		toggleShowImagesAndSave({ commit, state }) {
			commit("toggleShowImages");

			localStorage.setItem("showImages", state.showImagesState);
		},
		clearAllCheckboxesAndSave({ commit, state }, payload) {
			commit("clearAllCheckboxes", payload);

			let obj = state.checkboxState;
			let data = Object.keys(obj).filter(key => obj[key] === true).join(",");
			localStorage.setItem("checked", data);
		}
	}
})

app.use(store)

document.addEventListener("DOMContentLoaded", () => {
	app.mount("#app");
});

</script>

</body>
</html>
