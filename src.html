<!DOCTYPE html>
<html>
<head>

<title>BG3 Item Checklist</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="./favicon.png"/>
<link rel="stylesheet" href="./style.css"></style>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="./data.js"></script>
<script>

function get_difficulty_mod(difficulty) {
	switch (difficulty) {
		case "explorer": return 0.5;
		case "balanced": return 0;
		case "tactician": return -0.5;
		case "honour": return -0.5;
	}
}

<!-- See https://bg3.wiki/wiki/Trading_and_item_pricing and https://bg3.wiki/wiki/Widget:PriceCalculator -->
function get_final_price(value, persuasion_mod = 4, attitude = 0, difficulty = "balanced") {
	let difficulty_mod = get_difficulty_mod(difficulty);
	let price_mod = Math.max(1.0, 2.5 - 0.1*persuasion_mod - 0.005*attitude - difficulty_mod);
	value = value.split(" / ");
	if (value.length == 1 || difficulty != "honour")
		value = value[0];
	else
		value = value[1];
	value = parseInt(value.replace(" gp", ""));
	let price_buy = Math.round(value * price_mod);
	return price_buy + " gp";
}

document.addEventListener("DOMContentLoaded", () => {

	const app = Vue.createApp({
		template: `
<h1 class="center">BG3 Item Checklist</h1>
<p class="center"><a href="https://github.com/joe1817/BG3-Item-Checklist">GitHub</a></p>
<h2 class="center">Table of Contents</h2>

<div id="back-to-top" class="text-button noselect">Back to Top</div>

<div id="TOC">
	<ol v-for="act in acts">
		<li>
			<ul>
				<li v-for="section in act.entries" :class="{started: sectionProgress(section) > 0, completed: sectionProgress(section) == sectionTotal(section)}">
					<span class="header">
						<a :href="'#'+section.id">{{ section.title }}</a>
						<span class="progress">{{ sectionProgress(section) }}/{{ sectionTotal(section) }}</span>
					</span>
				</li>
			</ul>
		</li>
	</ol>
</div>

<fieldset id="filters" class="noselect"><legend>Filters</legend>
	<div v-for="filter in filters" class="category" tabindex="0" @focus="calcSubcatHeight($event)" @mouseover="calcSubcatHeight($event)" @blur="nullSubcatHeight($event)" @mouseout="nullSubcatHeight($event)">
		<div class="filter category-filter main-filter" :class="{enabled: filter.enabled}">
			<span class="eye" @click="toggleFilter(filter)">👁️</span>
			<span>{{ filter.title }}</span>
		</div>
		<div class="subcategories">
			<div v-for="subfilter in filter.subfilters" class="filter category-filter sub-filter" :class="{enabled: subfilter.enabled}">
				<span class="eye" @click="toggleSubFilter(subfilter, filter)">👁️</span>
				<span>{{ subfilter.title }}</span>
			</div>

		</div>
	</div>
</fieldset>

<div id="search"></div>

<div class="entry-container" id="table">

	<div v-for="act in acts" class="act entry-container" :id="act.id" :class="{started: actProgress(act) > 0, completed: actProgress(act) == actTotal(act), expanded: act.expanded}" :style="{mayHeight: act.collaped ? '0px' : null}">
		<div class="header"><span class="eye noselect" @click="act.expanded = !act.expanded; expandContent($event, act.expanded); saveCollapsed()">👁️</span><span class="title">{{ act.title }}</span><span class="progress">{{ actProgress(act) }}/{{ actTotal(act) }}</span><span class="text-button noselect" @click="clearCheckboxes();">Clear</span></div>

		<div class="content">

			<div v-for="section in act.entries" class="section entry-container" :id="section.id" :class="{started: sectionProgress(section) > 0, completed: sectionProgress(section) == sectionTotal(section), expanded: section.expanded}"  :style="{mayHeight: section.collaped ? '0px' : null}">

				<div class="header"><span class="eye noselect" @click="section.expanded = !section.expanded; expandContent($event, section.expanded); saveCollapsed()">👁️</span><span class="title">{{ section.title }}</span><span class="progress">{{ sectionProgress(section) }}/{{ sectionTotal(section) }}</span></div>

				<div class="content">

					<div v-if="section.tip" class="tip" v-html="section.tip"></div>

					<div v-for="entry in section.entries" :class="['entry', entry.categories, entry.rarity, {'top-tier': entry.suggested, 'completed': entry.completed}]" :id="entry.id" v-show="showEntry(entry)">
						<span class="checkbox"><input type="checkbox" v-model="entry.completed" @change="saveCheckboxes()"></span>
						<span class="img"><img :src="entry.img" width=50 height=50></span>
						<span class="title"><a :href="entry.link">{{ entry.title }}</a></span>
						<span class="desc" v-html="entry.desc"></span>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
`,
		data() {
			return {
				acts    : entryData,
				filters : filters
			};
		},
		mounted() {
			console.log("mounted");
			this.loadChecked();
			this.loadCollapsed();
			this.loadDisabled();
		},
		methods: {
			showEntry(entry) {
				console.log("in showEntry")
				for (const filter of this.filters) {
					for (const cat of entry.categories) {
						if (filter.categories.includes(cat) && filter.enabled) {
							return true;
						}
					}
					for (const subfilter of filter.subfilters) {
						for (const cat of entry.categories) {
							if (subfilter.categories.includes(cat) && filter.enabled) {
								return true;
							}
						}
					}
				}
				return false;
			},
			loadChecked() {
				let checked = localStorage.getItem("checked") || "";
				checked = checked.split(",");
				for (const act of this.acts) {
					for (const section of act.entries) {
						for (const entry of section.entries) {
							if (checked.includes(entry.id)) {
								entry.completed = true;
								//section.progress++;
								//act.progress++;
							}
						}
					}
				}
			},
			loadCollapsed() {
				let collapsed = localStorage.getItem("collapsed") || "";
				collapsed = collapsed.split(",");
				for (const act of this.acts) {
					if (collapsed.includes(act.id)) {
						act.expanded = !act.expanded;
					}
					for (const section of act.entries) {
						if (collapsed.includes(section.id)) {
							section.expanded = !section.expanded;
						}
					}
				}
			},
			loadDisabled() {
				let toggledFilters = localStorage.getItem("disabled") || "";
				toggledFilters = toggledFilters.split(",");
				for (const filter of this.filters) {
					if (toggledFilters.includes(filter.title)) {
						filter.enabled = !filter.enabled;
					}
					for (const subfilter of filter.subfilters) {
						if (toggledFilters.includes(subfilter.title)) {
							subfilter.enabled = !subfilter.enabled;
						}
					}
				}
			},
			saveCheckboxes() {
				console.log("saving checkboxes");
				// save to local storage
				let data = [];
				for (const act of this.acts) {
					for (const section of act.entries) {
						for (const entry of section.entries) {
							if (entry.completed) {
								data.push(entry.id);
							}
						}
					}
				}
				data = data.join(",");
				localStorage.setItem("checked", data);
			},
			saveCollapsed() {
				// save to local storage
				let data = [];
				for (const act of this.acts) {
					if (!act.expanded) {
						data.push(act.id);
					}
					for (const section of act.entries) {
						if (!section.expanded) {
							data.push(section.id);
						}
					}
				}
				data = data.join(",");
				localStorage.setItem("collapsed", data);
			},
			saveDisabled() {
				// save to local storage
				let data = [];
				for (const filter of this.filters) {
					if (!filter.enabled) {
						data.push(filter.title);
					}
					for (const subfilter of filter.subfilters) {
						if (!subfilter.enabled) {
							data.push(subfilter.title);
						}
					}
				}
				data = data.join(",");
				localStorage.setItem("disabled", data);
			},
			clearCheckboxes() {
				for (const act of this.acts) {
					for (const section of act.entries) {
						for (const entry of section.entries) {
							entry.completed = false;
						}
					}
				}
				this.saveCheckboxes();
			},
			toggleFilter(filter) {
				filter.enabled = !filter.enabled;
				for (const subfilter of filter.subfilters) {
					//if (subfilter.enabled != filter.enabled)
					subfilter.enabled = filter.enabled;
				}
				this.saveDisabled();
			},
			toggleSubFilter(subfilter, filter) {
				subfilter.enabled = !subfilter.enabled;
				const count = filter.subfilters.filter(sf => sf.enabled).length;
				if (count == filter.subfilters.length) {
					filter.enabled = true;
				} else if (count == 0) {
					filter.enabled = false;
				}
				// TODO half-eye
				this.saveDisabled();
			},
			expandContent(event, expand) {
				// TODO use refs
				const contentDiv = event.currentTarget.parentNode.nextSibling;
				if (expand) {
					contentDiv.style.maxHeight = contentDiv.scrollHeight + "px";
				} else {
					contentDiv.style.maxHeight = "0px";
				}
			},
			calcSubcatHeight(event) {
				// TODO use refs
				const subcategoriesDiv = event.currentTarget.children[1];
				subcategoriesDiv.style.maxHeight = subcategoriesDiv.scrollHeight + "px";
			},
			nullSubcatHeight(event) {
				// TODO use refs
				const subcategoriesDiv = event.currentTarget.children[1];
				subcategoriesDiv.style.maxHeight = "0px";
			},
			actProgress(act) {
				let sum = 0;
				for (const section of act.entries) {
					sum += this.sectionProgress(section);
				}
				return sum;
			},
			actTotal(act) {
				let sum = 0;
				for (const section of act.entries) {
					sum += this.sectionTotal(section);
				}
				return sum;
			},
			sectionProgress(section) {
				let sum = 0;
				for (const entry of section.entries) {
					if (entry.completed && this.showEntry(entry)) {
						sum++;
					}
				}
				return sum;
			},
			sectionTotal(section) {
				let sum = 0;
				for (const entry of section.entries) {
					if (this.showEntry(entry)) {
						sum++;
					}
				}
				return sum;
			}
		}
	});
	app.mount("#app");

	// back to top
	const backToTop = document.getElementById("back-to-top");

	window.addEventListener("scroll", () => {
		if (window.scrollY > 1200) {
			backToTop.classList.add("show");
		} else {
			backToTop.classList.remove("show");
		}
	});

	backToTop.addEventListener("click", () => {
		window.scrollTo({
			top: 0,
			behavior: "smooth"
		});
	});

	// load sprites
	const fullImage = new Image();
	fullImage.src = "./sprites.png";
	fullImage.onload = () => {
		document.querySelectorAll(".sprite").forEach(img => {
			const canvas = document.createElement("canvas");
			const ctx = canvas.getContext("2d");
			const [x, y] = img.id.split("-");
			const cropX = parseInt(x);
			const cropY = parseInt(y);
			const cropWidth = 50;
			const cropHeight = 50;
			canvas.width = cropWidth;
			canvas.height = cropHeight;
			ctx.drawImage(fullImage, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
			img.src = canvas.toDataURL();
		});
	};






	// calculate buy prices from entry value
	document.querySelectorAll(".value").forEach(value => {
		value.innerText = get_final_price(value.innerText);
	});

	// enables collapsibles to start open
	document.querySelectorAll(".section .content").forEach(content => {
		content.style.maxHeight = content.scrollHeight + "px";
	});

	// img click -> checkbox
	document.querySelectorAll(".entry").forEach(entry => {
		entry.querySelector("img").addEventListener("click", () => {
			let checkbox = entry.querySelector("input");
			checkbox.checked = !checkbox.checked;
			checkbox.dispatchEvent(new Event("change"));
		});
	});
});
</script>

</head>
<body>

<div id="app"></div>

</body>
</html>
